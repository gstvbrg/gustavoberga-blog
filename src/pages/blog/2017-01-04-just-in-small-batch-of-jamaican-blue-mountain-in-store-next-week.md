---
templateKey: blog-post
path: /jammin
title: Jammin'
date: 2017-01-16T15:04:10.000Z
description: 'JAMStack: GatsbyJS + NetlifyCMS'
---
<iframe width="560" height="315" src="https://www.youtube.com/embed/RAW1wj3Lx0I?rel=0&amp;showinfo=0" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
<br/><br/>

**_VASTLY_** nerdier than how Bob Marley’s anthems urge us to rethink politics, JAMstack evangelist want to elevate how we think about web development; moving beyond the battles among frameworks towards a higher level re-evaluation of web architecture.  

## **J**avascript – **A**PIs – **M**arkup

As Bob Marley says, **"None but ourselves can free our minds..."** _but_ excellent documentation at [Netlify](https://www.netlify.com/blog/2017/06/06/jamstack-vs-isomorphic-server-side-rendering/) and [JAMstack.org](https://jamstack.org/) has absolutely helped. So let me summarize some of these big ideas which make this methodology so useful. Especially for projects (like this blog) in which popular isomorphic tools can be increasingly optimized to remove unnecessary overhead and redundancy. 

#### **Laying down the baseline**

It can’t be understated how much progress in recent web development stems from the continued trend of seamlessly using Javascript on the client and server. In the broadest sense, these isomorphic (universal) frameworks can harness powerful cloud machines to cleverly optimize and accelerate performance on the client, all while facilitating more ingenuitive data and state management. The runaway success of this wave of frameworks is Facebook’s open source tag-team React and Redux; whose ability to maintain an internal representation of the client on the server, enable it to intelligently direct client rendering and unify data flow in innovative ways. Not to mention the insanely improved developer experience afforded by deeper integration of browsers with server powered build tools; allowing all the patching, debugging, reloading, linting, and testing we now take for granted. 

Much like Bob Marley’s warnings about the modern world (I’m *really* committed to this ‘Jammin’ pun), maybe these futuristic amenities are stroking our egos into doing more work than is necessary. Even a modest ability to orchestrate this can embolden one to feel like they just hand assembled an electric ferrari-hummer and are ready to race around the world... wide-web. It’s gratifying and impressive (possibly enchanting?) but in many cases all you actually needed was an Uber ride. 

> **Bad programmers worry about the code. Good programmers worry about data structures and their relationships.** 
> <br/> – Linus Torvalds

All considered, it’s no wonder that we often aim to match the ambitions of our projects with equally ambitious tooling, overlooking simpler alternatives. 

#### **Enter the JAMStack**
 

This is where we’re challenged to see the forest in the trees. To recognize the big trends related to the continued growth of available APIs, innovative CDNs making deployment fool-proof, and services allowing developers to more easily create and consume hosted databases. If you allow these innovations to converge and bring along the best features of intelligent module bundlers, you end up with next generation site generators aimed to be faster and more flexible than current frameworks like WordPress. Better still are the site generators like [Gatsby.js](https://www.gatsbyjs.org/), which allow you to use React and it’s common workflow to effortlessly reap the benefits of its optimizations. _**AND**_ the cherry on top is that almost everything aforementioned pushes your site towards being a proper [Progressive Web App](https://developers.google.com/web/progressive-web-apps/) as advocated by Google (That is native-feeling web apps that use a minimum 'shell-app' on initial load, propagated by service workers and caching, to achieve super fast loading and offline features).

#### **JAM Synergy™**

Bringing it all together, let's look at how Markdown emphasizes all the best practices of JAMstack methodology. 

Using Markdown format as common currency for styled components to package raw text into DOM is efficient; but how should we efficiently organize, store, and fetch this text? Time for some **JAM Synergy™**, where each technology complements the others. Using **J**SX to transform **M**arkdown into DOM suggests text-formatting standards and best practices that most developers already know or can easily learn. This sets up easy reuse of independent  content and view components, and it keeps us in Node.js land where we can make use of all our cloud service **A**PIs and related tooling (think [GraphQl servers](https://www.prismagraphql.com/) and [Apollo Client](https://www.apollographql.com/client)). It's here that the magic happens as our tiny, CDN-hosted files can be wired up with real-time data sources allowing for rich interfaces and dynamic interactions. 

#### **Fine Wine**

In some form this methodology has been around for many years, and like many innovations it can seem obvious and uninteresting almost instantly given many developers familiarity with the underlying technology. 

But the important distinction today is the incredible growth and availability of both open-source tools and cloud services which make this architecture accessible to the average developer. Moreover I thinks it's a new high-water mark for the potential of individual developers; as there's never been more cloud services **_and_** they've never been easier to integrate **_and_** it all promotes the best user experience the web has to offer. 

